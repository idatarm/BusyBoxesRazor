<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <title>BUSY BOXES FAQ</title>
    </head>
    <body>
        <p>
            <b style="font-size:larger">Q:</b> What is Busy Boxes? Is it a game? A research project? What?
        </p>
        <p>
            <b style="font-size:larger">A:</b> Busy Boxes (BBX) is an implementation of the 3D reversible cellular automata developed by Ed Fredkin and Daniel B. Miller in their 2005 paper,
            <a href="http://dl.acm.org/citation.cfm?id=1062261.1062271">Two State, Reversible, Universal Cellular Automata In Three Dimensions</a>. 
            A preprint is available <a href="http://arxiv.org/pdf/nlin/0501022">here</a>.
        </p>
        <p>
            We have just posted a more recent paper to the arXiv, entitled
            <a href="http://arxiv.org/abs/1206.2060">Circular Motion of Strings in Cellular Automata, and Other Surprises</a>. The paper includes informational links back to this website.
        </p>
        <br/>
        <p>
            <b style="font-size:larger">Q:</b> What is the point? Are there any goals, or levels?
        </p>
        <p>
            <b style="font-size:larger">A:</b> There are open questions about what the BBX algorithm is capable of. In particular, we would like to know if BBX is capable of 
            Universal Construction, in the sense outlined by Von Neumann in <i>The Theory of Self-Reproducing Automata (1966)</i>.
            In simple terms the question is, can  you build a machine in BBX that can build another machine similar to itself?
        </p>
        <p>
            Before we answer that question, we will need to answer a number of smaller but interesting questions. While we know that BBX is capable of Universal Computation,
            it's not at all clear how to build practical examples of effective computation within a finite implementation. As discussed in the paper, we can
            <a href="/?16#A/Tflebhkbhib0">route information</a>, and perform
            <a href="/?17#A/ablbfelfriWbbhil0">rudimentary logic operations</a>.
            However, it is far from obvious how, in practical terms, useful computation can be performed within a limited, finite lattice. Presumably, 
            <a href="http://en.wikipedia.org/wiki/Reversible_logic">reversible logic</a> would be used; however, it is interesting to note that while our universe
            is based on reversible physics, we generally build computation machines using traditional, irreversible Boolean logic. The extra information created by
            these operations is turned into heat (which is why faster computers need bigger fans!)
        </p>
        <br/>
        <p>
            <b style="font-size:larger">Q:</b> What's all this about reversibility? Isn't this just like the Game Of Life, only in 3D?
        </p>
        <p>
            <b style="font-size:larger">A:</b> The Game Of Life (GOL) and BBX are both cellular automata, and both have been shown to be 
            <i>Turing complete</i>, which means that you can build computers inside the game that can process information in arbitrary ways.
            The interesting thing about BBX and related algorithms (such as the <a href="http://en.wikipedia.org/wiki/Billiard_ball_computer">Billiard Ball computer</a>,
            <a href="http://arxiv.org/pdf/0806.0127v1">implemented as a Cellular Automata</a>)
            is that they have a set of rules that is reversible, meaning that you can reverse the flow of time and recover the exact states that you had before.
            You can't do that in the GOL (think of a single cell which dies; reversing time, it's just a blank cell forever.)
        </p>
        <p>
            Reversibility introduces some very interesting properties, including a number of things which seem intriguingly related to physical laws that we observe 
            in our own universe (the laws of physics are also reversible.) For instance, because BBX is reversible, if we run it in a finite space (this implmentation
            uses a 3D lattice of 24 * 24 * 24, or 13,284 cells), we know that eventually, any pattern will repeat itself. This means that it is impossible (in a finite implementation of BBX)
            to build a structure (from within the game) that lasts forever. That's how we knew that 
            <a href="/?23#A/fiZilfamfbfddVlbjebbi1lfbfPbfjfdlfhuibecdpfdfplelhWffambfshYlfTjlbebhmfpjjlfqZUbfWnWlfjRtbfcqdlfkkfbfdcqlfhiYbfaijlfnYmbfesVlfiVmbfZicl0">this</a>
            would eventually come to 
            <a href="/?24#A/fcfilTfbTflTfbVhlVhbVhlXehbUiXehlUiXehbVhlVhbejeffeUXlfopebfXiolVhbVhlVhbVhlThbThlThbThlXefbfndVl0">this</a> (it takes about 60,000 generations!)
            We believe this relates in a deep way to entropy, the laws of thermodynamics, and the apparent asymmetrical nature of time.
        </p>
        <p>
            We can also use reversibility to prove that, for example, two
            <a href="/?00#A/Qbefl0">2-cell gliders</a> cannot combine to create one <a href="/?30/#A/Qbhilbhibbdal0">4-cell glider</a>. If they could, then we would be able
            to reverse the flow of time, and the 4-cell glider would spontaneously break up into two 2-cell gliders. We can see clearly that the 4-cell glider is stable
            if it doesn't interact with any other cells, so this is impossible.  However, three 2-cell gliders <i>can</i> combine to make a 2-cell and a 4-cell glider,
            <a href="/?31/#A/boblbihbecmkdehleRQfdfib0">like this</a>.
        </p>
        <br/>
        <p>
            <b style="font-size:larger">Q:</b> So what are the rules?
        </p>
        <p>
            <b style="font-size:larger">A:</b> The rules of this Cellular Automata are as follows:
        </p>
        <p>
            <ul>
                <li>Play takes place on a 3D Cartesian lattice of cells.</li>
                <li>Each cell in the lattice is either <i>odd</i> or <i>even</i>, depending on whether the sum of the three coordinates specifying that cell's location in the lattice is odd or even.</li>
                <li>Cells are either 1 or 0.  1 cells are shown as red if they are <i>even</i>, or blue if they are <i>odd</i>. 0 cells are not shown.</li>
                <li>There are six phases in the evolution of the CA, numbered 0 to 5.  During even phases, only <i>even</i> cells are operated on. During odd phases, <i>odd</i> cells are operated on.</li>
                <li>During phase 0 and 3, the <i>planar rule</i> is applied to the XY plane. During phase 1 and 4, it is applied to the YZ plane.  During phase 2 and 5, it is applied to the ZX plane.</li>
                <li>The <i>planar rule</i> is this: for each diagonally situated pair of cells on the plane, if a 1 exists at either of the pair's <i>knight's move</i> 
                positions, the value of the two cells in that diagonal pair is swapped.  However, this only happens if there is no conflicting swap for either cell.</li>
                <li>The <i>knight's move</i> positions for a diagonal pair of cells are the cells that can be reached from both cells in the pair by moving two in one axis and one in another. A picture helps:
                <pre>
                    X - - -                 - - - X
                    - - * -                 - * - -
                    - * - -                 - - * -
                    - - - X                 X - - -
                </pre>
                The X's are the <i>knight's move</i> positions for the pairs of cells represented by asterisks.
                 </li>
                <li>In this bounded implementation, swaps are not allowed with cells outside the boundary.</li>
                <p>
                    Note that since only swaps are allowed, the number of 1's and 0's is fixed for any set of initial conditions. One may think of the BBX CA as a set of rules for moving 1's around on the lattice.
                </p>
            </ul>
        </p>
        <div style="display:none">
        	<img src="tracking_faq.jpg"></img>
        </div>
    </body>
</html>
