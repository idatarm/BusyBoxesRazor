<!DOCTYPE HTML>
<html lang="en">
    <head>
        <!--
        The MIT License
        
        Copyright (c) 2010-2012 danx0r (Daniel B. Miller), Authors of three.js. 
        All rights reserved.
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.
        -->
        <title>BUSY BOXES</title>
        <meta charset="utf-8">
        <style type="text/css">
            body {
                font-family: Monospace;
                font-size: 12px;
                background-color: #f0f0f0;
                margin: 0px;
                overflow-x: hidden;
            }
            .bannerButtons {
                opacity: 0.7;
            }
            .bannerButtons:hover {
                opacity: 1.0;
                border-color:black;
            }
            .goHash {
                font-family:monospace;
                font-size:large;
                #color:blue;
                #background:none;
                border:none;
                padding:0;
                #border-bottom:1px solid;
                background-color:#ddd;
                opacity:0.7;
            }
            .goHash:hover {
                background-color:white;
            }
        </style>
    </head>
    <body style="overflow-y:hidden">
        <div id="moodal_background" style="position:absolute;width:100%;height:100%;background-color:black;z-index:100;opacity:0.2;display:none">
        </div>
        <div id="trail_type" style="display:none">
            Trail length:<input class="moodal_default" id="trail_length" tabindex=1 type="text" value="100"></input><br/>
            <p></p>Select trail type:</p>
            <button tabindex=2 onclick="moodal_choice('cell')">Trails for every cell</button>
            <button tabindex=3 onclick="moodal_choice('average')">Trail for average</button>
        </div>
        <div id="trails_disabled" style="display:none">
            <p></p>Trails are now disabled</p>
                <button onclick="moodal_choice('OK')" style="font-size:large;padding:4px 15px 4x 15px">OK</button>
        </div>
        <div id="random_prompt" style="display:none">
            Volume width:<input id="random_prompt_width" class="moodal_default" tabindex=2 type="text" value="4"></input><br/>
            Cell count:<input id="random_prompt_count"  tabindex=3 type="text" value="16"></input><br/>
            Red/Blue ratio:<input id="random_prompt_ratio"  tabindex=4 type="text" value="0.5"></input><br/>
            <br/>
            <button  tabindex=5 onclick="moodal_choice('CANCEL')">CANCEL</button>
            <button tabindex=6 onclick="moodal_choice('OK')" style="border:ridge;border-color:black;border-style:double;">OK</button>
        </div>
        <div id="leftLinks" style="position:absolute;font-size:large">
            <div style="opacity:0.7">
                Generation:
                <span id="generation"></span>
                <br/>
                phase:
                <span id="showphase"></span>
                <br/>
                Direction:
                <span id="direction"></span>
                <br/>
                Speed:
                <span id="showspeed">fast</span>
                <br/>
                Cells:
                <span id="cellcount"></span>
                <br/>
                Cursor:
                <span id="cursorpos"></span>
                <br/>
                Hash:
                <span id="showhash" style="font-size:smaller"></span>
                <br/>
                <span id="showinfo"></span>
                <span id="duplicates"></span>
            </div>
            <span id="debug"></span>
            <br/>
            <button class="goHash" id="introHash" onclick="selectHash('PeciXwDuTA0', this)">Intro</button>
            <br/>
            <button class="goHash" onclick="selectHash('GJR0', this)">Glider 1</button>
            <br/>
            <button class="goHash" onclick="selectHash('UMlSpB0', this)">Glider 2</button>
            <br/>
            <button class="goHash" onclick="selectHash('IYKmDcRzB0', this)">Glider 3</button>
            <br/>
            <button class="goHash" onclick="selectHash('IYKmDIA0', this)">Glider 4</button>
            <br/>
            <button class="goHash" onclick="selectHash('PB0jwU0vAB0', this)">Glider 5</button>
            <br/>
            <button class="goHash" onclick="selectHash('PR0cME0nAA0', this)">Glider 6</button>
            <br/>
            <button class="goHash" onclick="selectHash('IFIWA0', this)">Cycle 1 (12)</button>
            <br/>
            <button class="goHash" onclick="selectHash('csmKB0', this)">Cycle 2 (12)</button>
            <br/>
            <button class="goHash" onclick="selectHash('AQGk0', this)">Cycle 3 (24)</button>
            <br/>
            <button class="goHash" onclick="selectHash('BwF6Ao40', this)">Cycle 4 (36)</button>
            <br/>
            <button class="goHash" onclick="selectHash('UMXTUukA0', this)">Cycle 5 (42)</button>
            <br/>
            <button class="goHash" onclick="selectHash('ACRAs0', this)">Cycle 6 (60)</button>
            <br/>
            <button class="goHash" onclick="selectHash('sIECiMgQKE0', this)">Cycle 7 (84)</button>
            <br/>
            <button class="goHash" onclick="selectHash('IDYCyj0B5', this)">Cycle 8 (144)</button>
            <br/>
            <button class="goHash" onclick="selectHash('cICOg2CB0', this)">Cycle 9 (582)</button>
            <br/>
            <button class="goHash" onclick="selectHash('sICMBZBAULIB0', this)">Cycle 10 (3966)</button>
            <br/>
            <button class="goHash" onclick="selectHash('Tc9FLA0', this)">Boomerang (60)</button>
            <br/>
            <button class="goHash" onclick="selectHash('HS8UNxTp0', this)">Deflect (Routing)</button>
            <br/>
            <button class="goHash" onclick="selectHash('XUcUN4Ab3pB0', this)">Logic (Interaction Gate)</button>
            <br/>
            <button class="goHash" onclick="selectHash('cs6dxwG0', this)">Move</button>
            <br/>
            <button class="goHash" onclick="selectHash('MLDQ3S82JzTA0', this)">Fast and Slow</button>
            <br/>
            <button class="goHash" onclick="selectHash('EAHuexNzTmB0', this)">Capture and emit</button>
            <br/>
            <button class="goHash" onclick="selectHash('QAgIjoICCzCBB0', this)">Delayed release</button>
            <br/>
            <button class="goHash" onclick="selectHash('vwB3JyPaCCCPQCCCPQCCCPQCCD1dPHzPM0', this)">Attraction</button>
            <br/>
            <button class="goHash" onclick="selectHash('MnCTi7uMxOftTl7px47ec4vgSHgMH4FTu5zo-AZk5eecBOvjnR8BSU5ecunSHFwcvwEh4BOm.APh4eTqSB0', this, 24)" id="order_chaos">Order Out of Chaos</button>
            <br/>
            <button class="goHash" onclick="selectHash('UHfALungB5AgUEEegIFBBHoCBwAj0BAoII9AQKCDydXwCsA0', this, 24)" id="struct_decay">Structure And Decay</button>
            <br/>
            <button class="goHash" onclick="selectHash('UkDEoQIHETAnBgQo9IUYECBwzo6Q4AQSdAUmCBDhoQOAcCCDOjoIBAgcAUmCnB0CBAgcQ9Abg6KHATBSdAYOE4OkUUIFBejBAgcIJOgIEDgBBJ1BwnBgwcQ9AUY9ACToCBxE6QoIJwdIcI9IUKPQECBwBB0', this)">
                Big Bang (Entropy)</button>
            <br/>
            <button class="goHash" onclick="selectHash('HefAXExMTE8Axy.Ag7vAMcuJicpw854AUqVKlSpUqVL8Bz4JUaKVKl0', this, 40)" id="strung_out">Strung out</button>
            <br/>
            <button class="goHash" onclick="selectHash('EOjuPgFiYmJieAY8AnwIPgL4BzwBw0NDYnKeANLzngEo0aNH4DnwGSpUqVLR0', this, 40)" id="octave">Octave</button>
            <br/>
            <button class="goHash" onclick="selectHash('cDvPgDiQ0NiYngHPAN8CD4EeAc8AweA2Gh8DMSGhuc8APMcyWjRSpaPwGPgOlS0aB0', this, 40)" id="strung_out">Harmonic Chaos</button>
            <br/>
            <button class="goHash" onclick="selectHash('RZejhMkpklOTtLA0', this, 40, 250)" id="circular">Circular Motion</button>
            <br/>
        </div>
        <div style="display:none">
            <div id="banner">
                <span style="background-color: #fff; opacity:0.5; border-bottom: 1px solid #ddd; padding: 8px 10px; font-size:medium">
                    <b>click & drag to rotate view | scroll to zoom | arrows move cursor; U & D for up/down | ENTER to create/delete | S to step</b>
                </span>
                <div>
                    </p><button class="bannerButtons" onclick="toggleRunning()">RUN/STOP</button>
                    <button class="bannerButtons" onclick="fastSlow()">FAST/SLOW</button>
                    <button class="bannerButtons" onclick="isRunning = true; mainLoop(); isRunning = false;">STEP</button>
                    <button class="bannerButtons" onclick="reverseDirection()">DIRECTION</button>
                    <button class="bannerButtons" onclick="randomCells(12, -2, 1)">RANDOM</button>
                    <button class="bannerButtons" onclick="playStopMusic()">MUSIC</button>
                    <button class="bannerButtons" onclick="toggleTrails()">TRAILS</button>
                    <button class="bannerButtons" onclick="clearGrid()">CLEAR</button>
                    <button class="bannerButtons" onclick="update()">UPDATE</button>
                    <button class="bannerButtons" onclick="reset()">RESET</button>
                </div>
                <a href="faq.html" target="_blank" style="font-size:larger">faq</a>
                |
                <a href="https://github.com/danx0r/BusyBoxes" target="_blank" style="font-size:larger">source</a>
            </div>
        </div>
        <script type="text/javascript" src="js/ThreeCanvas.js"></script>
        <script type="text/javascript" src="js/Cube.js"></script>
        <script type="text/javascript" src="js/Plane.js"></script>
        <script type="text/javascript" src="js/encdec.js"></script>
        <script type="text/javascript" src="js/moodal.js"></script>
        <script type="text/javascript">
            //<![CDATA[
            var DEBUG = false;
            var CELL_TRAIL = false;
            var AVG_TRAIL = false;
            var trail = [];
            var trails = [];
            var offs1 = [+2, +1, -1, -2, +2, +1, -1, -2];
            var offs2 = [+1, +2, +2, +1, -1, -2, -2, -1];
            var move1 = [+1, -1, +1, -1, +1, -1, +1, -1];
            var move2 = [-1, +1, +1, -1, +1, -1, -1, +1];
            var cursor = [0, 0, 0];
            var gLastCursor = cursor;
            var grid = {};
            var isRunning = false;
            var direction = "forward";
            var lasthash = "";
            var gUpdateHash = "";
            var gInitialHash = "";
            var gInitialFrame;
            var encodeString = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-";
            var frame = 0;
            var cellCount = 0;
            var mode = "mirror";
            var axisMin = -12;
            var axisMax = 11;
            var processSpeed = "fast";
            var lastSelectedEl;
            var gLastRefreshedUrl;
            var scrollBarX = false;
            var moveFifo = [];
            for (var i=0; i<60; i++) moveFifo.push(0);
            var qargs = {};
            var container, interval,
            camera, scene, renderer,
            projector, plane, cube, linesMaterial,
            color = 0,colors = [ 0xDF1F1F, 0xDFAF1F, 0x80DF1F, 0x1FDF50, 0x1FDFDF, 0x1F4FDF, 0x7F1FDF, 0xDF1FAF, 0xEFEFEF, 0x303030 ],
            ray, brush, objectHovered,
            isMouseDown = false, onMouseDownPosition,
            radious = 2000, theta = 0, onMouseDownTheta = 45, phi = 60, onMouseDownPhi = 60;
            randWidth = 4, randCount = 12, randRatio = 0.5;

            init();
            render();

            function parseQueryArgs() {
                var queryArgs = {};
                var searchString = document.URL;
                var i = searchString.indexOf("?");
                if (i < 0) return queryArgs;
                searchString = searchString.substr(i + 1);
                i = searchString.indexOf("/");
                if (i < 0) {
                    i = searchString.indexOf("#");
                }
                if (i < 0) {
                    i = searchString.length;
                }
                searchString = searchString.substr(0, i);
                var queryArgList = searchString.split("&");
                for (var i = 0; i < queryArgList.length; i++) {
                    var query = queryArgList[i];
                    var keyval = query.split("=");
                    var key = keyval[0];
                    if (keyval.length <= 1) keyval.push(true);
                    queryArgs[key] = keyval[1];
                }
                return queryArgs;
            }

            function init() {
                if (DEBUG) console.log("init start")
                qargs = parseQueryArgs();
                if (qargs.dir) {
                    direction = qargs.dir;
                }
                if (qargs.size) {
                    var size = parseInt(qargs.size);
                    axisMax = parseInt(size / 2) - 1;
                    axisMin = axisMax - (size - 1);
                    radious *= size/24.0;
                }
                if (qargs.trail) {
                    AVG_TRAIL = parseInt(qargs.trail);
                }
                if (qargs.trails) {
                    CELL_TRAIL = parseInt(qargs.trails);
                }
                if (qargs.mode) {
                    mode = qargs.mode;
                }
                if (DEBUG) console.log("DEBUG query args:", qargs, "axisMax:", axisMax, "axisMin:", axisMin)
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                var info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '5px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = document.getElementById("banner").innerHTML;
                container.appendChild( info );
 
                camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
                if(DEBUG) console.log("camera:", camera);
                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
//                camera.position.y = 200;

                scene = new THREE.Scene();

                // Grid

                var geometry = new THREE.Geometry();
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( axisMin * 50, 0, 0 ) ) );
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( (axisMax+1) * 50, 0, 0 ) ) );

                linesMaterial = new THREE.LineColorMaterial( 0x000000, 0.2 );

                if (!qargs.nogrid) {
                    for (var i = 0; i <= axisMax - axisMin + 1; i++) {
                    
                        var line = new THREE.Line(geometry, linesMaterial);
                        line.position.z = (i * 50) + axisMin * 50;
                        scene.addObject(line);
                        
                        var line = new THREE.Line(geometry, linesMaterial);
                        line.position.x = (i * 50) + axisMin * 50;
                        line.rotation.y = 90 * Math.PI / 180;
                        scene.addObject(line);
                        
                    }
                }

                projector = new THREE.Projector();

                plane = new THREE.Mesh( new Plane( 1000, 1000 ) );
                plane.rotation.x = - 90 * Math.PI / 180;
                scene.addObject( plane );
                
                if (qargs.dim == 2) {
                    cube = new Square( 50, 50, 50 );
                    phi = 180;
                    adjustCamera();
                }
                else {
                    cube = new Cube( 50, 50, 50 );
                }
                cubette = new Cube(10, 10, 10);

                ray = new THREE.Ray( camera.position, null );

                brush = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ], 0.4 ) );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                brush.overdraw = true;
                scene.addObject( brush );

                onMouseDownPosition = new THREE.Vector2();

                // Lights

                var ambientLight = new THREE.AmbientLight( 0x404040 );
                scene.addLight( ambientLight );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                var directionalLight = new THREE.DirectionalLight( 0x808080 );
                directionalLight.position.x = - 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = - 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                renderer = new THREE.CanvasRenderer();
                if (renderer.invalid) {
                    //alert ("CANVAS element not supported")
                    document.location = "nocanvas.html"; 
                }
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.appendChild(renderer.domElement);

                document.addEventListener( 'keydown', onDocumentKeyDown, false );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );

                document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
                document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false );

                if (window.location.hash) {
                    buildFromHash();
                }
                else {
                    if (qargs.hash) {
                        buildFromHash(qargs.hash);
                        if (qargs.sel) {
                            lastSelectedEl = document.getElementById(qargs.sel);
                            lastSelectedEl.style.backgroundColor = "cyan";
                            if (history.replaceState) {
                                var url = "" + window.location;
                                var i = url.indexOf('&sel=');
                                if (i > -1) {
                                    var j = i + 1 + url.substr(i+1).indexOf('&');
                                    url = url.substr(0, i) + url.substr(j);
                                    history.replaceState(url, url, url);
                                }
                            }
                        }
                    }
                    else {
                        if (qargs.coords) {
                            var coords = [];
                            var s = qargs.coords.split(",(");
                            for (var i=0; i<s.length; i++) {
                                var coord = s[i].replace("(", "")
                                coord = coord.split(",");
                                for (var j=0; j<3; j++) {
                                    coord[j] = parseInt(coord[j]);
                                }
                                coords.push(coord);
                            }
                            buildFromCoords(coords);
                        }
                        else {
                            selectHash('PeciXwDuTA0', document.getElementById("introHash"));
                        }
                    }
                }
                gInitialHash = gUpdateHash;
                gInitialFrame = frame;
                setInterval(mainLoopFast, 14);
                setInterval(mainLoopSlow, 140);
                setTimeout(mainLoopScience, 10);
                render();
                if (qargs.play) {
                    setTimeout(function() {
                        if (!isRunning) {
                            toggleRunning();
                        }
                    }, 2500);
                }
                if (qargs.science == "test") {
                    scienceTest();
                }
            }
            
            function mainLoopFast() {
                if (processSpeed == "fast") {
                    mainLoop();
                }
            }
            
            function mainLoopSlow() {
                if (document.getElementById("leftLinks").clientHeight >= window.innerHeight) {
                    if (!scrollBarX) {
                        scrollBarX = true;
                        document.body.style.overflowY="scroll";
                    }
                }
                else {
                    if (scrollBarX) {
                        scrollBarX = false;
                        document.body.style.overflowY="hidden";
                    }
                }
                if (processSpeed == "slow") {
                    mainLoop();
                }
            }
            
            function mainLoopScience() {
                if (isRunning && processSpeed == "science") {
                    for (var i=0; i<1000; i++) {
                        mainLoop(true);                     // no render during main loop for speed
                    }
                    render();
                    setTimeout(mainLoopScience, 0);
                }
                else {
                    setTimeout(mainLoopScience, 10);
                }
            }
            
            function mainLoop(noRender) {
                document.getElementById("generation").innerHTML = frame;
                document.getElementById("showphase").innerHTML = (frame % 6 + 6) %6;
                document.getElementById("direction").innerHTML = direction;
                if (isRunning) {
                    if (direction == "reverse") {
                        frame--;
                    }
                    if(DEBUG) console.log("frame:", frame)
                    var cells = [];
                    for(var key in grid) {
                        var xyz = eval('[' + key + ']')
                        cells.push([xyz, grid[key]]);
                    }
                    if(DEBUG) console.log("cells:", cells)
                    var moves = []
                    var x1, x2                                          // our two axes for today
                    switch( trueMod(frame, 3) ) {                      // ach, Javascript you old goat
                        case 0: x1=0; x2=1; break;
                        case 1: x1=1; x2=2; break;
                        case 2: x1=2; x2=0; break;
                    }
                    if (DEBUG) console.log("frame:", frame, "parity:", frame & 1, ['red','blue'][frame & 1], ['x','y','z'][x1], ['x','y','z'][x2])
                    for (var i in cells) {
                        var cell = cells[i];
                        if(DEBUG) console.log(cell[0], cell[1]);
                        var xyz = cell[0];
                        
                        if (((xyz[0] + xyz[1] + xyz[2]) & 1) == (frame & 1)) {                  // only operate on cells appropriate for this phase
                            if(DEBUG) console.log("DEBUG cell:", xyz, "-----------------------------------");
                            var move = getMove(xyz, x1, x2);
                            if (move) {
                                var mvto = [xyz[0] + move[0], xyz[1] + move[1], xyz[2] + move[2]];
                                if(!getGrid(mvto)) {
                                    var mv = getMove(mvto, x1, x2);                             // tricky -- read the paper. Can only move if the location we move to would have moved to us (swap)
                                    if (mv && mv[0] + move[0] == 0 && mv[1] + move[1] == 0 && mv[2] + move[2] == 0) {
                                        if(DEBUG) console.log("  mvto:", mvto);
                                        moves.push([xyz, cell[1], mvto]);
                                    }
                                }
                            }
                        }
                    }
                    if (AVG_TRAIL) {
                        avg = [0, 0, 0];
                        var len = 0;
                        for (var key in grid) {
                            len++;
                            var cell;
                            eval("cell=[" + key + "]");
                            for (var j = 0; j < 3; j++) {
                                avg[j] += cell[j];
                            }
                        }
                        for (var j = 0; j < 3; j++) {
                            avg[j] /= len;
                        }
                        var make = true;
                        if (trail.length) {
                            var obj = trail[trail.length - 1];
                            var x = avg[0] * 50 + 25;
                            var y = avg[1] * 50 + 25;
                            var z = avg[2] * -50 - 25;
                            if (x == obj.position.x && y == obj.position.y && z == obj.position.z) make = false; // don't add one if nothing has changed
                        }
                        if (make) {
                            if (qargs.logtrail) {
                                log("LOG_TO_FILE\ntrail.log\n" + avg[0] + "," + avg[1]+','+avg[2] + "\n")
                            }
                            var voxel = new THREE.Mesh(cubette, new THREE.MeshColorFillMaterial(colors[2]));
                            setObjPosition(voxel, avg);
                            voxel.overdraw = true;
                            scene.addObject(voxel);
                            trail.push(voxel);
                            if (trail.length > AVG_TRAIL) {
                                scene.removeObject(trail[0]);
                                trail = trail.splice(1);
                            }
                        }
                        //console.log("trail length:", trail.length)
                    }
                    if (qargs.info) {
                        moveFifo = moveFifo.slice(1).concat(moves.length);
                        var avg = 0;
                        for (var i = 0; i < moveFifo.length; i++) {
                            avg += moveFifo[i];
                        }
                        avg /= moveFifo.length;
                        document.getElementById("showinfo").innerHTML = "moves: " + 
                            htmlPadSpaces(moves.length, 3) +
                            " avg: " + avg.toFixed(3) + " per cell: " + (avg / cellCount).toFixed(3)
                            + "<br/>";
                        if (qargs.info=="log") {
                            log("LOG_TO_FILE\ninfo.log\n" + avg + "," + (avg / cellCount) + "\n");
                        }
                    }
                    for (i in moves) {
                        var args = moves[i];
                        moveCell(args[0], args[1], args[2]);
                    }
                    if (!noRender) {
                        render();
                    }
                    if (direction == "forward") {
                        frame++;
                    }
                    updateHash(true);
                }
            }
            
            function getMove(xyz, x1, x2) {
                if(x1 == null) x1 = 0;
                if(x2 == null) x2 = 2;
                var move = null;
                var d = [0, 0, 0]
                for (i = 0; i < 8; i++) {
                    d[x1] = offs1[i];
                    d[x2] = offs2[i];
                    if (getGrid([xyz[0] + d[0], xyz[1] + d[1], xyz[2] + d[2]])) {
                        var mv = [0, 0, 0];
                        mv[x1] = move1[i];
                        mv[x2] = move2[i];
                                                                            if (DEBUG) console.log("  mv:", mv);
                        if (move == null) {
                            move = mv;
                                                                            if (DEBUG) console.log("  move:", move);
                        }
                        else {
                            if (!v3eq(move, mv)) {
                                move = false;                               // conflicting moves -- give up
                                                                            if (DEBUG) console.log("  move:", move);
                                break;
                            }
                        }
                    }
                }
                if (move && mode == "mirror") {
                    for (var axis = 0; axis < 3; axis++) {
                        if (xyz[axis] + move[axis] > axisMax) {
                            move = false;
                            break;
                        }
                        if (xyz[axis] + move[axis] < axisMin) {
                            move = false;
                            break;
                        }
                    }
                }
                return move
            }
            
            function v3eq(v1, v2){
                return (v1[0] == v2[0] && v1[1] == v2[1] && v1[2] == v2[2]);
            }

            function moveCell(oldxyz, mesh, newxyz) {
                if (CELL_TRAIL) {
                    var voxel = new THREE.Mesh(cubette, new THREE.MeshColorFillMaterial(colors[4]));
                    setObjPosition(voxel, oldxyz);
                    voxel.overdraw = true;
                    scene.addObject(voxel);
                    trails.push(voxel);
                    if (trails.length > CELL_TRAIL) {
                        scene.removeObject(trails[0]);
                        trails = trails.splice(1);
                    }
                    //console.log("trails:", trails.length)
                }
                setObjPosition(mesh, newxyz);
                delGrid(oldxyz);
                putGrid(mesh, newxyz);
            }

            // convert grid coord to 3D coord and set obj.position accordingly given vector [x,y,z]
            function setObjPosition(obj, xyz) {
                obj.position.x = xyz[0] * 50 + 25;
                obj.position.y = xyz[1] * 50 + 25;
                obj.position.z = xyz[2] * -50 - 25;
            }
            
            function setBrushPosition(xyz) {
                setObjPosition(brush, xyz);
                if ((xyz[0] + xyz[1] + xyz[2]) % 2 == 0) {
                    setBrushColor(0);                    
                }
                else {
                    setBrushColor(5);                    
                }
                document.getElementById("cursorpos").innerHTML = xyz[0] + "," + xyz[1] + "," + xyz[2]
            }

            function putGrid(obj, xyz) {
                grid[xyz] = obj;
            }

            function trueMod(v, base) {
                if (v < 0) {
                    return ((v % base) + base) % base;
                }
                return v % base;
            }

            function getGrid(xyz) {
                if (mode == "wrap") {
                    for (var i = 0; i < 3; i++) {
                        if (xyz[i] < axisMin || xyz[i] > axisMax) {
                            xyz[i] = trueMod(xyz[i] - axisMin, (axisMax - axisMin) + 1) + axisMin;
                        }
                    }
                }
                return grid[xyz]
            }

            function delGrid(xyz) {
                delete grid[xyz];
            }
            
            function toggleRunning(){
                if (isRunning) {
                    cursor = gLastCursor;
                    isRunning = false;
                }
                else {
                    gLastCursor = cursor;
                    cursor = [0, 2000, 0];
                    isRunning = true;
                }
                setBrushPosition(cursor);
            }
            
            function clampCursor() {
                for (var x=0; x<3; x++) {
                    if (cursor[x] < axisMin) cursor[x] = axisMin;
                    if (cursor[x] > axisMax) cursor[x] = axisMax;
                }
            }

            function reverseDirection(){
                document.getElementById("duplicates").innerHTML = "";
                if (direction == "forward") {
                    direction = "reverse";
                }
                else {
                    direction = "forward";
                }
                updateHash(true);
                document.getElementById("direction").innerHTML = direction;
            }

            function onDocumentKeyDown( event ) {
                if (gMoodalInEffect) {
                    if (event.keyCode == 27) {
                        moodal_choice("CANCEL");
                    }  
                    if (event.keyCode == 10 || event.keyCode == 13) {
                        moodal_choice("OK");
                    }  
                    return;
                }
//document.getElementById("debug").innerHTML = ''+event.keyCode;
//if(DEBUG) console.log("key:", event.keyCode);
                if (event.shiftKey || event.ctrlKey || event.altKey || event.altGraphKey) return;
                switch( event.keyCode ) {
                    case 37:                           // LEFT
                        event.preventDefault();
                        cursor[0]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 40:                           // DOWN
                        event.preventDefault();
                        cursor[2]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 39:                           // RIGHT
                        event.preventDefault();
                        cursor[0]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 38:                           // UP
                        event.preventDefault();
                        cursor[2]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 85:                           // U
                        event.preventDefault();
                        cursor[1]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 68:                           // D
                        event.preventDefault();
                        cursor[1]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 82:                           // R
                        event.preventDefault();
                        reset();
                        break;
                    case 83:                           // S
                        event.preventDefault();
                        isRunning = true;
                        mainLoop();
                        isRunning = false;
                        break;
                    case 32:                           // SPACE
                        event.preventDefault();
                        toggleRunning();
                        break;
                    case 191:                           // / ?
                        if (isRunning) {
                            toggleRunning();
                        }
                        event.preventDefault();
                        randomCells();
                        break;
                    case 188:                           // , <
                        event.preventDefault();
                        if (direction=="forward") {
                            reverseDirection();
                        }
                        break;
                    case 190:                           // . >
                        event.preventDefault();
                        if (direction=="reverse") {
                            reverseDirection();
                        }
                        break;
                    case 70:                            // F
                        event.preventDefault();
                        if (!isRunning) {
                            toggleRunning();
                        }
                        fastSlow();
                        break;
                    case 74:                            // J
                        event.preventDefault();
                        phi += 5.0;
                        adjustCamera();
                        render();
                        break;
                    case 75:                            // K
                        event.preventDefault();
                        phi -= 5.0;
                        adjustCamera();
                        render();
                        break;
                    case 78:                            // N
                        event.preventDefault();
                        theta += 5.0;
                        adjustCamera();
                        render();
                        break;
                    case 77:                            // M
                        event.preventDefault();
                        theta -= 5.0;
                        adjustCamera();
                        render();
                        break;
                    case 73:                            // I
                        event.preventDefault();
                        radious -= 50.0;
                        adjustCamera();
                        render();
                        break;
                    case 79:                            // J
                        event.preventDefault();
                        radious += 50.0;
                        adjustCamera();
                        render();
                        break;
                    case 10:                           // RETURN
                    case 13:
                        event.preventDefault();
                        if (isRunning) break;
                        var obj = getGrid(cursor);
                        if (obj) {
                            scene.removeObject(obj);
                            delGrid(cursor);
                        }
                        else {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ] ) );
                            putGrid(voxel, cursor);
                            setObjPosition(voxel, cursor);
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                        }
                        updateHash();
                        gInitialHash = lasthash;
                        gInitialFrame = frame;
                        render(); 
                        break;
                }
            }

            function adjustCamera(){
                camera.position.x = radious * Math.sin(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);
                camera.position.y = radious * Math.sin(phi * Math.PI / 360);
                camera.position.z = radious * Math.cos(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);
                if (DEBUG) console.log("camera:", camera.position)
                camera.updateMatrix();
            }

            function onDocumentMouseDown(event){
                if (gMoodalInEffect) return;
                if (scrollBarX && window.innerWidth - event.clientX < 30) {
                    return;
                }
                event.preventDefault();
                
                isMouseDown = true;
                
                onMouseDownTheta = theta;
                onMouseDownPhi = phi;
                onMouseDownPosition.x = event.clientX;
                onMouseDownPosition.y = event.clientY;
                
            }

            function onDocumentMouseMove( event ) {
                if (gMoodalInEffect) return;
                if(scrollBarX && window.innerWidth - event.clientX < 30) {
                    return;
                }
                var dx = event.clientX - onMouseDownPosition.x;
                var dy = event.clientY - onMouseDownPosition.y;
//if(DEBUG) console.log("dx, dy:", dx, dy)
                event.preventDefault();

                if ( isMouseDown ) {

                    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
                    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

                    phi = Math.min( 180, Math.max( 0, phi ) );

                    adjustCamera();
                    render();
                }

            }

            function onDocumentMouseUp( event ) {
                if (gMoodalInEffect) return;
                if(scrollBarX && window.innerWidth - event.clientX < 30) {
                    return;
                }
                //event.preventDefault();

                isMouseDown = false;

                onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
                onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

            }

            function onDocumentMouseWheel( event ) {
                if (gMoodalInEffect) return;
                event.preventDefault();
				if (event.detail) {							/// ugh, dumb Firefox hack
					if (event.detail > 0) {
						radious += 120;
					}
					else {
						radious -= 120;
					}
				}
				else {
                    if (event.wheelDeltayY) {
                        radious -= event.wheelDeltaY;       /// chrome?
                    }
                    else {
                        if (event.wheelDelta) {             /// IE! & opera I hear
                            radious -= event.wheelDelta;
                        }
                        // else fuggedaboudit
                    }
				}
            	if (DEBUG) console.log("mw ev:", radious)

                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.updateMatrix();

                render();

            }

            function setBrushColor( value ) {
                color = value;
                brush.material[ 0 ].color.setHex( colors[ color ] ^ 0x4C000000 );

                render();

            }

            function refreshUrl(hash) {
                //console.log("should refresh:", url);
                var url = hash2url(hash);
                gInitialHash = hash;
                gInitialFrame = frame;
                if (history.replaceState) {
                    if(url != gLastRefreshedUrl) {
                        history.replaceState(url, url, url);
                    }
                    gLastRefreshedUrl = url;
                }
                else {
                    document.location = url;
                }
            }

            function buildFromHash(hash) {
                var version = false;
                if (hash) {
                    version = "Y"; 
                }
                else {
                    version = window.location.hash.substr(1, 1);
                    hash = window.location.hash.substr(3);
                }
                var phase = hash.substr(hash.length-1, hash.length);
                frame = parseInt(phase);
                if ('' + frame == "NaN") {
                    frame = 0;
                }
                else {
                    hash = hash.substr( 0, hash.length - 1 );
                }

                if ( version == "A" ) {

                    var current = { x: 0, y: 0, z: 0, c: 0 }
                    var data = decode( hash );
                    var i = 0, l = data.length;

                    while ( i < l ) {

                        var code = data[ i ++ ].toString( 2 );

                        if ( code.charAt( 1 ) == "1" ) current.x += data[ i ++ ] - 32;
                        if ( code.charAt( 2 ) == "1" ) current.y += data[ i ++ ] - 32;
                        if ( code.charAt( 3 ) == "1" ) current.z += data[ i ++ ] - 32;
                        if ( code.charAt( 4 ) == "1" ) current.c += data[ i ++ ] - 32;
                        if ( code.charAt( 0 ) == "1" ) {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ current.c ] ) );
//                            voxel.position.x = current.x * 50 + 25;
  //                          voxel.position.y = current.y * 50 + 25;
    //                        voxel.position.z = current.z * 50 + 25;
                            setObjPosition(voxel, [current.x, current.y, current.z]);
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                            putGrid(voxel, [current.x, current.y, current.z])
                        }
                    }

                } else {
                    if (version == "X") {
                        var data = hash;
                        var cur = [0, 0, 0];
                        var x = 0;
                        var delta, sign;
                        while (x < data.length) {
                            for (var i = 0; i < 3; i++) {
                                if (data.charAt(x) == "_") {
                                    x++;
                                    delta = encodeString.indexOf(data.charAt(x++));
                                    sign = 1;
                                    if (delta >= 32) {
                                        sign = -1;
                                    }
                                    delta = (delta & 0x1f) << 6;
                                    delta += encodeString.indexOf(data.charAt(x++))
                                    delta *= sign;
                                }
                                else {
                                    delta = encodeString.indexOf(data.charAt(x++)) - 32;
                                }
                                cur[i] += delta;
                            }
                            var parity = (cur[0] + cur[1] + cur[2]) & 1;
                            var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[parity * 5]));
//                            voxel.position.x = cur[0] * 50 + 25;
  //                          voxel.position.y = cur[1] * 50 + 25;
    //                        voxel.position.z = cur[2] * 50 + 25;
                            setObjPosition(voxel, cur);
                            voxel.overdraw = true;
                            scene.addObject(voxel);
                            putGrid(voxel, cur);
                        }
                    }
                    else {
                        if (version == "Y") {
                            var data = hash;
                            data = encdec_decode(data);
                            var cur = [0, 0, 0];
                            var x = 0;
                            var delta, sign;
                            while (x < data.length) {
                                for (var i = 0; i < 3; i++) {
                                    delta = data[x++];
                                    cur[i] += delta;
                                }
                                var parity = (cur[0] + cur[1] + cur[2]) & 1;
                                var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[parity * 5]));
     //                           voxel.position.x = cur[0] * 50 + 25;
       //                         voxel.position.y = cur[1] * 50 + 25;
         //                       voxel.position.z = cur[2] * 50 + 25;
                                setObjPosition(voxel, cur);
                                voxel.overdraw = true;
                                scene.addObject(voxel);
                                putGrid(voxel, cur);
                            }
                        }
                        else {
                            alert("Unknown encoding type: " + version);
                        }
                    }
                }
                updateHash();

            }

            function buildFromCoords(coords){
                for(var i=0; i<coords.length; i++) {
                    var cur = coords[i];
                    var parity = (cur[0] + cur[1] + cur[2]) & 1;
                    var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[parity * 5]));
                    setObjPosition(voxel, cur);
                    voxel.overdraw = true;
                    scene.addObject(voxel);
                    putGrid(voxel, cur);
                }
                updateHash();
            }
            
            function hash2url(hash){
                var sep = "?";
                var url = "" + window.location;
                if (url[url.length-1] == "/") url = url.substr(0, url.length-1)
                var i = url.indexOf('?hash=');
                if (i == -1) {
                    i = url.indexOf('&hash=');
                    if (i == -1) {
                        if (url.indexOf("?") > -1) 
                            sep = "&"
                        i = url.indexOf("/#");
                        if (i == -1) {
                            i = url.length;
                        }
                    }
                    else {
                        sep = "&";
                    }
                }
                url = url.substr(0, i) + sep + "hash=" + hash;
                return url;
            }

            function updateHash(noLink) {
                var key, keys = [];
                for (key in grid) {
                    keys.push(key);
                }
                keys.sort();
                var oldCount = cellCount;
                cellCount = 0;
                var data = [];
                var cur = [0, 0, 0];
                if (qargs.science == true) var coords = [];
                for (var k in keys) {
                    key = keys[k];
                    xyz = eval("[" + key + "]");
                    if (qargs.science == true) coords.push('(' + xyz + ')');
                    var skip = false;
                    for (var j = 0; j < 3; j++) {
                        if (xyz[j] < axisMin || xyz[j] > axisMax) {
                            skip = true;
                            break;
                        }
                    }
                    if (skip) continue;
                    for (var j = 0; j < 3; j++) {
                        var delta = xyz[j] - cur[j];
                        data.push(delta);
                    }
                    cur = xyz;
                    cellCount++;
                }

                data = encdec_encode(data);
                data +=     (frame % 6 + 6) % 6

                if (!noLink) {                          // yuck. The part of my job I hate
                    gUpdateHash = data;
                }
                if (data != lasthash) {
                    if (data == gInitialHash) {
                        document.getElementById("duplicates").innerHTML = "cycle: " + Math.abs(frame - gInitialFrame) + " match: frame " + frame + "=" + gInitialFrame;
                        gInitialFrame = frame;
                    }
                }
                document.getElementById('cellcount').innerHTML = cellCount;
                if (cellCount != oldCount) {
                    gInitialHash = data;
                    gInitialFrame = frame;
                }
                lasthash = data;
                if (!isRunning && typeof(console) != "undefined" && console.log) console.log("last hash:", data);
                if (data.length > 12) {
                    data = data.substr(0,5) + ".." + data.substr(data.length-5)
                }
                document.getElementById('showhash').innerHTML = data;
                if (qargs.science == true && typeof(console) != "undefined" && console.log) console.log(''+coords)
            }

            function render() {
                renderer.render( scene, camera );

            }

            function clearGrid() {
                cursor = [0, 0, 0]
                setBrushPosition(cursor);
                clearScreen();
                if (lastSelectedEl) lastSelectedEl.style.backgroundColor="#ddd";
                processSpeed = "slow";
                updateHash();
                refreshUrl(gUpdateHash);
            }

            function reset(hash) {
                if (!hash) hash = gUpdateHash;
                cursor = gLastCursor;
                setBrushPosition(cursor);
                clearScreen();
                buildFromHash(hash);
                refreshUrl(gUpdateHash);
                document.getElementById("duplicates").innerHTML = ""; 
            }
            
            function update(){
                if (lastSelectedEl) {
                    lastSelectedEl.style.backgroundColor="#ddd";
                }
                updateHash();
                refreshUrl(gUpdateHash);
            }
            
            function selectHash(hash, el, size, trail) {
                if (!trail) {
                    AVG_TRAIL = false;
                    CELL_TRAIL = false;
                }
                if (trail || (size && size != (axisMax - axisMin + 1))) {
                    var trailopt = "";
                    if (trail) {
                        trailopt = "&trail=" + trail;
                    }
                    document.location = "/?size=" + size + trailopt + "&sel=" + el.id + "&hash=" + hash;
                }
                else {
                    if (lastSelectedEl) {
                        lastSelectedEl.style.backgroundColor = "#ddd";
                    }
                    reset(hash);
                    el.style.backgroundColor = "cyan";
                    lastSelectedEl = el;
                }
            }

            function clearScreen() {
                isRunning = false;
                grid = {};
                var i = 0;

                while ( i < scene.objects.length ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

                        scene.removeObject( object );
                        continue;
                    }

                    i ++;
                }

                frame = 0;
                trail = [];
                trails = [];
                lasthash = "";
                if (!qargs.science) direction = "forward";
                document.getElementById("direction").innerHTML = direction;
                document.getElementById("generation").innerHTML = "";
                document.getElementById("showphase").innerHTML = "";
                document.getElementById("duplicates").innerHTML = "";
                document.getElementById("cellcount").innerHTML = "";
                setTimeout(render, 100);
            }
            
            function randomCells(){
                document.getElementById("random_prompt_width").value = '' + randWidth;
                document.getElementById("random_prompt_count").value = '' + randCount;
                document.getElementById("random_prompt_ratio").value = '' + randRatio;
                moodal("random_prompt", function(result){
                    console.log("result:", result)
                    if (result != "OK") return;
                    var width = parseFloat(document.getElementById("random_prompt_width").value);
                    var count = parseInt(document.getElementById("random_prompt_count").value);
                    var ratio = parseFloat(document.getElementById("random_prompt_ratio").value);
                    var axMax, axMin;
                    if (width != parseInt(width)) {
                        var tot = axisMax - axisMin;
                        width = parseInt(tot * width);
                        axMax = [axisMax, axisMax, axisMax];
                        axMin = [tot - width + axisMin, axisMin, axisMin];
                    }
                    else {
                        width = parseInt(width);
                        randWidth = width;
                        randCount = count;
                        randRatio = ratio;
                        axMax = parseInt(width - .5) >> 1;
                        axMin = axMax - (width - 1);
                        axMax = [axMax, axMax, axMax];
                        axMin = [axMin, axMin, axMin];
                    }
                    clearScreen();
                    if (lastSelectedEl) 
                        lastSelectedEl.style.backgroundColor = "#ddd";
                    cursor = [0, 2000, 0];
                    for (i = 0; i < count; i++) {
                        var phase = -1;
                        var targPhase = i < (count * ratio - 0.5)?0:1;
                        while ((cursor in grid) || (phase != targPhase)) {
                            for (var axis = 0; axis < 3; axis++) {
                                cursor[axis] = Math.floor(Math.random() * (axMax[axis] - axMin[axis] + 1) + axMin[axis]);
                            }
                            phase = (cursor[0] + cursor[1] + cursor[2]) & 1;
                        }
                        setBrushPosition(cursor);
                        var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[color]));
                        putGrid(voxel, cursor);
                        setObjPosition(voxel, cursor);
                        voxel.overdraw = true;
                        scene.addObject(voxel);
                    }
                    
                    updateHash();
                    refreshUrl(gUpdateHash);
                });
            }

            // https://gist.github.com/665235

            function decode( string ) {

                var output = [];
                string.split('').forEach( function ( v ) { output.push( "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf( v ) ); } );
                return output;

            }

            function encode( array ) {

                var output = "";
                array.forEach( function ( v ) { output += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt( v ); } );
                return output;

            }

            function fastSlow() {
                switch (processSpeed) {
                    case "slow":
                        processSpeed = "fast";
                        break;
                    case "fast":
                        processSpeed = qargs.science?"science":"slow";
                        break;
                    case "science":
                        processSpeed = "slow";
                        break;
                }
                document.getElementById("showspeed").innerHTML = processSpeed;
            }

            function playStopMusic() {
                var el = document.getElementById("music");
                if (!el) {
                    //console.log("loading music:", el)
                    var el = document.createElement('div');
                    el.style.display = 'none';
                    el.innerHTML = '<audio id="music" src="prisoner_ambient003.ogg" loop="true"></audio>';
                    document.body.appendChild(el);
                }
                if (!document.musicPlaying) {
                    //console.log("playing music:", el)
                    document.getElementById("music").load(); // well this fixes the chrome bug, but forces play from top
                    document.getElementById("music").play();
                    document.musicPlaying = true;
                }
                else {
                    //console.log("stopping music:", el);
                    document.getElementById("music").pause();
                    document.musicPlaying = false;
                }
            }
            
            function toggleTrails() {
                if (AVG_TRAIL || CELL_TRAIL) {
                    AVG_TRAIL = false;
                    CELL_TRAIL = false;
//                    alert("Trails disabled");
                    moodal('trails_disabled', function () {
                    })
                    var t = trails.concat(trail);
                    for (var i=0; i<trail.length + trails.length; i++) {
                        var obj = t[i];
                        scene.removeObject(obj);
                    }
                    trail = [];
                    trails = [];
                }
                else {
                    moodal("trail_type", function (result) {
                        var len = parseInt(document.getElementById("trail_length").value);
                        if (result == 'cell') {
                            CELL_TRAIL = len;
                        }
                        else {
                            AVG_TRAIL = len;
                        }
                    });
                }
            }
            
            function htmlPadSpaces(n, pad) {
                var s = '' + n;
                var len = s.length;
                for (var i=0; i < pad - len; i++) {
                    s = '&nbsp;' + s;
                }
                return s;
            }
            
            function log(s){
                var req = new XMLHttpRequest();
                if (req) {
                    req.onreadystatechange = function(){
                        if (req.readyState == 4) {
                            if (req.status && req.status != 200) {
                                Kata.error("Error loading Document: status " + req.status + " for url " + url);
                            }
                            else {
                                if (req.responseText.indexOf("OK") < 0) {
                                    alert("log error: " + req.responseText)
                                }
                            }
                        }
                    }
                    req.open("POST", "log.py", true);
                    req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                    req.send(s);
                }
            }


            function scienceTest(){
                console.log("SCIENCE!");
                gScienceCounterInit = 100000;
                gScienceTrials = 1000;
                gScienceBatch = 1000;
                gScienceTrial = 0;
                scienceTestInit();
            }

            function scienceTestInit() {
                document.getElementById("debug").innerHTML = "" + gScienceTrial + " out of " + gScienceTrials;
                gScienceCounter = gScienceCounterInit;
                randomCells_(5, 12, 0.25);
                console.log("DEBUG frame at beginning:", frame);
                gStartHash = lasthash;
                processSpeed = "test";
                //console.log("DEBUG lasthash:", lasthash)
                isRunning = true;
                setTimeout(scienceTestLoop, 10);
            }   
        
            function scienceTestLoop(){
                var startCellCount = cellCount;
                var count = Math.min(gScienceCounter, gScienceBatch);
                for (var i = 0; i < count; i++) {
                    mainLoop(true);
                    //console.log("DEBUG trial:", gScienceTrial, "frame:", frame, "counter:", gScienceCounter)
                    gScienceCounter--;
                    if ((lasthash == gInitialHash) || (startCellCount != cellCount)) {
                        gScienceCounter = 0;
                        break;
                    }
                }
                render();
                if (gScienceCounter) {
                    setTimeout(scienceTestLoop, 1);
                }
                else {
                    console.log("DEBUG trial over. gScienceCounter: ", gScienceCounter, "trial:", gScienceTrial, "hash:", gStartHash)
                    isRunning = false;
                    processSpeed = "slow";
                    var result;
                    if (startCellCount != cellCount) {
                        result = "death";
                    }
                    else if (lasthash == gInitialHash) {
                        result = "cycle,";
                    }
                    else {
                        result = "timeout,,";
                    }
                    log("LOG_TO_FILE\nscience.log\ntrial," + gScienceTrial + ",hash," + gStartHash + "," + result + "," + frame + "\n");
                    gScienceTrial++;
                    if (gScienceTrial < gScienceTrials) {
                        scienceTestInit();
                    }
                    else {
                        alert("Science as we know it is over");
                    }
                }
            }
            //]]>
        </script>
        <div style="display:hidden">
            <img src="tracking.jpg"></img>
        </div>
    </body>
</html>
